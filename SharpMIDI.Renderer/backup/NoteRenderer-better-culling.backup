using Raylib_cs;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Numerics;
using SharpMIDI;

namespace SharpMIDI.Renderer
{
    public static unsafe class NoteRenderer
    {
        [StructLayout(LayoutKind.Sequential, Pack = 1)]
        private struct MergeNote
        {
            public float x1, x2;
            public uint color;
            public byte height;
            public byte noteLayer;
            public bool glowing;
        }

        [StructLayout(LayoutKind.Sequential, Pack = 1)]
        private struct PackedRect
        {
            public Raylib_cs.Rectangle rect;
            public Raylib_cs.Color color;
        }

        private const int RECT_CAPACITY = 16777216;
        private static PackedRect[] packedRects = new PackedRect[RECT_CAPACITY];

        private static readonly MergeNote[] mergeNotePool = new MergeNote[128];
        private static readonly bool[] validPool = new bool[128];

        private static float cachedYScale = 0f;
        private static float cachedWindow = 0f;
        private static float cachedScreenWidth = 0f;
        private static float cachedScreenHeight = 0f;
        private static int cachedPadding = 0;

        private static readonly Dictionary<uint, uint> glowColorCache = new(256);

        public static int LastFrameRectCount { get; private set; } = 0;
        public static bool EnableGlow { get; set; } = true;
        public static float Window { get; set; } = 2000f;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Initialize(int screenHeight, int padding)
        {
            cachedScreenHeight = screenHeight;
            cachedPadding = padding;
            cachedYScale = (screenHeight - padding * 2) / 128f;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        public static int FindStartIndex(float visibleStart, float windowBuffer)
        {
            if (NoteProcessor.allNotes.Length == 0) return 0;

            int lo = 0, hi = NoteProcessor.allNotes.Length - 1, result = 0;

            while (lo <= hi)
            {
                int m = lo + ((hi - lo) >> 1);
                ref var note = ref NoteProcessor.allNotes[m];

                // Use a more conservative buffer for the binary search
                if (note.endTime >= visibleStart - windowBuffer * 2f)
                {
                    result = m;
                    hi = m - 1;
                }
                else
                {
                    lo = m + 1;
                }
            }

            // Conservative backtrack to ensure we don't miss any visible notes
            while (result > 0)
            {
                ref var prevNote = ref NoteProcessor.allNotes[result - 1];
                if (prevNote.endTime < visibleStart - windowBuffer * 2f) break;
                result--;
            }

            return result;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static int BuildVisibleRectangles(float tick, int screenWidth, int screenHeight, int padding)
        {
            // Cache dimension updates - avoid repeated calculations
            if ((screenWidth != (int)cachedScreenWidth) | (screenHeight != (int)cachedScreenHeight) | (padding != cachedPadding))
            {
                cachedScreenWidth = screenWidth;
                cachedScreenHeight = screenHeight;
                cachedPadding = padding;
                cachedYScale = (screenHeight - (padding << 1)) * 0.0078125f; // 1/128 as constant
            }

            // Early exit without lock if possible
            var allNotes = NoteProcessor.AllNotes;
            if (allNotes.Length == 0) return 0;

            // Pre-calculate all constants once
            float windowHalf = Window * 0.5f;
            float start = tick - windowHalf;
            float end = tick + windowHalf;
            float scale = screenWidth / Window;
            float offset = -start * scale;
            float startMinusBuffer = start - Window * 0.05f;
            float screenWidthF = screenWidth;
            float yBase = screenHeight - padding;
            bool enableGlow = EnableGlow;
            int noteCount = allNotes.Length;
            int capacityLimit = RECT_CAPACITY - 128;

            // Simplified clearing - only what we actually use
            unsafe
            {
                fixed (bool* validPtr = validPool)
                {
                    // Clear in 64-byte chunks for better cache efficiency
                    ulong* validUlong = (ulong*)validPtr;
                    for (int i = 0; i < 16; i++) validUlong[i] = 0;      // 128 bools = 16 ulongs
                }
            }

            int startIdx = FindStartIndex(start, Window * 0.05f);
            int count = 0;

            // Main loop with aggressive inlining and minimal branching
            for (int i = startIdx; i < noteCount; i++)
            {
                ref var n = ref allNotes[i];

                // Early termination check - most restrictive first
                if (n.startTime > end) break;
                if (n.endTime < startMinusBuffer) continue;

                // Fast coordinate calculation with bit operations where possible
                float x1 = n.startTime * scale + offset;
                float x2 = n.endTime * scale + offset;

                // Simplified bounds check - avoid Vector2 allocation
                if ((x2 <= 0f) | (x1 >= screenWidthF)) continue;

                // Clamp without function calls
                x1 = (x1 > 0f) ? x1 : 0f;
                x2 = (x2 < screenWidthF) ? x2 : screenWidthF;

                int ny = n.noteNumber;
                byte currentLayer = n.noteLayer;

                // Inline glow calculation to avoid function call overhead
                uint finalColor = n.color;
                bool isGlowing = false;
                if (enableGlow)
                {
                    isGlowing = (tick >= n.startTime) & (tick <= n.endTime);
                    if (isGlowing) finalColor = GetGlowColorCached(n.color);
                }

                // Smart merge check with enhanced spatial overlap detection
                ref var newMerge = ref mergeNotePool[ny];
                if (validPool[ny])
                {
                    ref var existing = ref mergeNotePool[ny];

                    // Pack all merge conditions into single evaluation
                    uint mergeConditions = 
                        ((currentLayer == existing.noteLayer) ? 1u : 0u) |
                        ((isGlowing == existing.glowing) ? 2u : 0u) |
                        ((x1 - existing.x2 <= 2f) ? 4u : 0u);

                    if (mergeConditions == 7u) // All conditions met (1|2|4 = 7)
                    {
                        if (x2 > existing.x2) existing.x2 = x2;
                        continue;
                    }
                    else
                    {
                        // Enhanced overlap analysis for partial coverage
                        bool existingIsHigher = existing.noteLayer > currentLayer;
                        bool currentIsHigher = currentLayer > existing.noteLayer;
                        
                        // Calculate actual overlap region
                        float overlapStart = Math.Max(x1, existing.x1);
                        float overlapEnd = Math.Min(x2, existing.x2);
                        bool hasOverlap = overlapStart < overlapEnd;
                        
                        if (hasOverlap)
                        {
                            // Check for complete coverage
                            bool currentCompletelyCoversExisting = (x1 <= existing.x1) && (x2 >= existing.x2);
                            bool existingCompletelyCoversCurrent = (existing.x1 <= x1) && (existing.x2 >= x2);
                            
                            if (existingIsHigher && existingCompletelyCoversCurrent)
                            {
                                // Current note is completely hidden behind existing higher layer - skip it
                                continue;
                            }
                            else if (currentIsHigher && currentCompletelyCoversExisting)
                            {
                                // Current note completely covers existing lower layer - replace it
                                newMerge.x1 = x1;
                                newMerge.x2 = x2;
                                newMerge.color = finalColor;
                                newMerge.height = n.height;
                                newMerge.glowing = isGlowing;
                                newMerge.noteLayer = currentLayer;
                                continue;
                            }
                            // PARTIAL COVERAGE CASE: Both notes should be drawn
                            // Fall through to emit existing and add current
                        }
                        // No overlap or partial overlap - emit existing note
                        
                        EmitRect(existing, ny, yBase, count);
                        count++;
                    }
                }

                // Create new merge entry - direct struct assignment
                newMerge.x1 = x1;
                newMerge.x2 = x2;
                newMerge.color = finalColor;
                newMerge.height = n.height;
                newMerge.glowing = isGlowing;
                newMerge.noteLayer = currentLayer;
                validPool[ny] = true;

                // Break early if approaching capacity
                if (count >= capacityLimit) break;
            }

            // Final emission with unrolled loop for better cache usage
            for (int ny = 0; (ny < 128) & (count < RECT_CAPACITY); ny++)
            {
                if (validPool[ny])
                {
                    ref var r = ref mergeNotePool[ny];
                    EmitRect(r, ny, yBase, count);
                    count++;
                }
            }

            LastFrameRectCount = count;
            return count;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static void EmitRect(in MergeNote r, int ny, float yBase, int index)
        {
            float noteY = yBase - (ny + 0.5f) * cachedYScale;
            float rectY = noteY - r.height * 0.5f;
            float width = r.x2 - r.x1;

            packedRects[index].rect = new Raylib_cs.Rectangle(r.x1, rectY, width, r.height);
            uint c = r.color;
            packedRects[index].color = new Raylib_cs.Color(
                (byte)(c >> 16),
                (byte)(c >> 8),
                (byte)c,
                (byte)255
            );
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static uint GetGlowColorCached(uint baseColor)
        {
            if (glowColorCache.TryGetValue(baseColor, out uint cached))
                return cached;

            uint glowColor = CalculateGlowColorFast(baseColor);

            if (glowColorCache.Count < 512)
                glowColorCache[baseColor] = glowColor;

            return glowColor;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static uint CalculateGlowColorFast(uint baseColor)
        {
            uint r = Math.Min(255u, (baseColor >> 16) & 0xFF) << 2;
            uint g = Math.Min(255u, (baseColor >> 8) & 0xFF) << 2;
            uint b = Math.Min(255u, baseColor & 0xFF) << 2;

            r = (r > 255u) ? 255u : r;
            g = (g > 255u) ? 255u : g;
            b = (b > 255u) ? 255u : b;

            return 0xFF000000u | (r << 16) | (g << 8) | b;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static void DrawRectangles(int count)
        {
            if (count == 0) return;

            const int BATCH_SIZE = 1024;
            int fullBatches = count / BATCH_SIZE;
            int remainder = count % BATCH_SIZE;

            fixed (PackedRect* rectPtr = packedRects)
            {
                for (int b = 0; b < fullBatches; b++)
                {
                    EmitRectBatch(rectPtr + b * BATCH_SIZE, BATCH_SIZE);
                }

                if (remainder > 0)
                {
                    EmitRectBatch(rectPtr + fullBatches * BATCH_SIZE, remainder);
                }
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static void EmitRectBatch(PackedRect* batch, int length)
        {
            for (int i = 0; i < length; i++)
            {
                Raylib.DrawRectangleRec(batch[i].rect, batch[i].color);
            }
        }

        public static void ClearGlowCache()
        {
            glowColorCache.Clear();
        }

        public static void Shutdown()
        {
            packedRects = null;
            glowColorCache.Clear();
        }
    }
}